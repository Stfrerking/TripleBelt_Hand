// Version: 2025-07-20
// Description: Updated for CAN-based control — joystick + button data now received over CAN

#include <PWMServo.h>
#include <Arduino.h>
#include <Encoder.h>
#include <FlexCAN_T4.h>

// ----------- Encoder Pins (Hardware Quadrature) ----------- //
#define ENC0_A 0
#define ENC0_B 1
#define ENC1_A 2
#define ENC1_B 3
#define ENC2_A 6
#define ENC2_B 7
#define ENC3_A 8
#define ENC3_B 9
#define ENC4_A 22
#define ENC4_B 23
#define ENC5_A 34
#define ENC5_B 35

Encoder encoder0(ENC0_A, ENC0_B);
Encoder encoder1(ENC1_A, ENC1_B);
Encoder encoder2(ENC2_A, ENC2_B);
Encoder encoder3(ENC3_A, ENC3_B);
Encoder encoder4(ENC4_A, ENC4_B);
Encoder encoder5(ENC5_A, ENC5_B);

// ----------- Motor Driver Pins ----------- //
#define MOTOR0_PWM_A 4
#define MOTOR0_PWM_B 5
#define MOTOR1_PWM_A 10
#define MOTOR1_PWM_B 11
#define MOTOR2_PWM_A 24
#define MOTOR2_PWM_B 25
#define MOTOR3_PWM_A 28
#define MOTOR3_PWM_B 29
#define MOTOR4_PWM_A 15
#define MOTOR4_PWM_B 14
#define MOTOR5_PWM_A 37
#define MOTOR5_PWM_B 36

// ----------- Current Sense Pins ----------- //
#define MOTOR0_SEN 21
#define MOTOR1_SEN 20
#define MOTOR2_SEN 19
#define MOTOR3_SEN 18
#define MOTOR4_SEN 17
#define MOTOR5_SEN 16

// ----------- Servo Pins ----------- //
#define SERVO0 33

// ----------- Motor Driver Pins Declaration ----------- //
#define PMODE 12
#define nFAULT 26
#define nSLEEP 27
#define vREF 13

// ----------- CAN Declaration ----------- //
FlexCAN_T4<CAN3, RX_SIZE_256, TX_SIZE_16> Can3;

volatile uint8_t requestedConfig = 0;
volatile bool configChangeRequested = false;



// ----------- Global ROM limits for Motor Limits ----------- //
long lowROM[6]  = {-100000, -100000, -100000, -100000, -100000, -100000};
long highROM[6] = {100000, 100000, 100000, 100000, 100000, 100000};

//#define HOMING_TIMEOUT 8000
Encoder* encoders[6] = { &encoder0, &encoder1, &encoder2, &encoder3, &encoder4, &encoder5 };
const int motorPWM_A[6]   = {MOTOR0_PWM_A, MOTOR1_PWM_A, MOTOR2_PWM_A, MOTOR3_PWM_A, MOTOR4_PWM_A, MOTOR5_PWM_A};
const int motorPWM_B[6]   = {MOTOR0_PWM_B, MOTOR1_PWM_B, MOTOR2_PWM_B, MOTOR3_PWM_B, MOTOR4_PWM_B, MOTOR5_PWM_B};
const int motorSEN[6]   = {MOTOR0_SEN, MOTOR1_SEN, MOTOR2_SEN, MOTOR3_SEN, MOTOR4_SEN, MOTOR5_SEN};
int PWM_A[6] = {0, 0, 0, 0, 0, 0};
int PWM_B[6] = {0, 0, 0, 0, 0, 0};



// Homing vREF voltage [PWM]
//cont int homingVoltage[6] = {127, 127, 127, 127, 127, 127};

// Homing speeds [0-100] PWM will be scalled later
//const int homingSpeeds[6] = {100, 80, 100, 80, 100, 80};

// Backoff durations [ms]
//const int backoffTimes[6] = {50, 100, 50, 100, 50, 100};

// Pullback distances after stall [encoder counts]
//const int pullbackCounts[6] = {10, 10, 10, 10, 10, 10};

// Stall debounce [ms] — time without motion before we consider it stuck
//const unsigned long stallDebounce[6] = {60, 80, 60, 80, 60, 80};

PWMServo servo0;

// Function declarations 
void sendEncoderPositions();
void sendRangeOfMotion();
//void homeMotors();
void nextState();
void handleState();
void printEncoderData();
void controlMotor(int index);
static void loadPwmArray(int *target, const CAN_message_t &msg);



//Declaration for finger configurations driven by servos
enum HandState { CONFIG_1, CONFIG_2, CONFIG_3, CONFIG_4 };
HandState currentState = CONFIG_1;

void handleCAN(const CAN_message_t &msg) {
  switch (msg.id) {
    case 0x200: {
      // Brain is sending PWM_A[0..5]
      if (msg.len >= 6) {
        loadPwmArray(PWM_A, msg);
      }
      break;
    }

    case 0x201: {
      // Brain is sending PWM_B[0..5]
      if (msg.len >= 6) {
        loadPwmArray(PWM_B, msg);
      }
      break;
    }

    case 0x100: {
      // Hand state / config command from brain
      // msg.buf[0] = desired config ID (0,1,2,3,...)
      if (msg.len >= 1) {
        requestedConfig = msg.buf[0];
        configChangeRequested = true;  // main loop will act on requestedConfig
      }
      break;
    }


    case 0x120: {
      // Homing request
      if (msg.len == 1 && msg.buf[0] == 1) {
        Serial.println("Homing request received via CAN");
        //homeMotors();
      }
      break;
    }

    default:
      // Ignore other IDs for now
      break;
  }
}


void setup() {
  Serial.begin(115200);
  analogReadResolution(12);

  for (int i = 0; i < 6; i++) {
  pinMode(motorPWM_A[i], OUTPUT);
  pinMode(motorPWM_B[i], OUTPUT);
}

  pinMode(PMODE, OUTPUT); 
  pinMode(vREF, OUTPUT);
  pinMode(nFAULT, INPUT);
  pinMode(nSLEEP, OUTPUT);

  servo0.attach(SERVO0);

  Can3.begin();
  Can3.setBaudRate(500000);
  Can3.enableMBInterrupts();
  Can3.onReceive(handleCAN);
  Serial.println("System Initialized (CAN-based)");

  digitalWrite(PMODE, LOW);
  digitalWrite(nSLEEP, HIGH);
  
  sendRangeOfMotion();
  handleState();
}

void loop() {
  sendEncoderPositions();
  
  Can3.events();

  controlMotor(0);
  controlMotor(1);
  controlMotor(2);
  controlMotor(3);
  controlMotor(4);
  controlMotor(5);

  if (configChangeRequested) {
    configChangeRequested = false;
    handleState();                  
  }

  /* static unsigned long lastPrint = 0;
  if (millis() - lastPrint >= 1000) {
    Serial.print("X: "); Serial.print(processedX); Serial.print("\tY: "); Serial.println(processedY);
    printEncoderData();

    for (int i = 0; i < 6; i++) {
      int raw = analogRead(motorSEN[i]);
      float voltage = raw * (3.3 / 4095.0);
      float current = voltage / 0.5;
      Serial.print("M"); Serial.print(i);
      Serial.print(": ADC="); Serial.print(raw);
      Serial.print("  I="); Serial.print(current, 3);
      Serial.print(" A   ");
    }
    Serial.println();
    lastPrint = millis(); 
  }*/
}

void nextState() {
  currentState = static_cast<HandState>((currentState + 1) % 4);
  Serial.print("Transitioned to state: ");
  Serial.println(currentState);
  handleState();
}

void handleState() {
  // Map requestedConfig (0,1,2,3,...) to HandState
  HandState newState;

  switch (requestedConfig) {
    case 0:
      newState = CONFIG_1;
      break;
    case 1:
      newState = CONFIG_2;
      break;
    case 2:
      newState = CONFIG_3;
      break;
    case 3:
      newState = CONFIG_4;
      break;
    default:
      // Ignore invalid values; keep current state
      Serial.print("Ignoring invalid requestedConfig: ");
      Serial.println(requestedConfig);
      return;
  }

  // If nothing changed, don't spam serial or move servos
  if (newState == currentState) {
    return;
  }

  currentState = newState;

  Serial.print("Transitioned to state: ");
  Serial.println(currentState);

  switch (currentState) {
    case CONFIG_1:
      Serial.println("State 1: One-sided Grip");
      servo0.write(160);
      break;

    case CONFIG_2:
      Serial.println("State 2: Pinch Grip");
      servo0.write(90);
      break;

    case CONFIG_3:
      Serial.println("State 3: Claw Grip");
      servo0.write(45);
      break;

    case CONFIG_4:
      Serial.println("State 4: Coffee Cup Grip");
      servo0.write(15);
      break;
  }
}


void controlMotor(int index) {
  analogWrite(motorPWM_A[index], PWM_A[index]);
  analogWrite(motorPWM_B[index], PWM_B[index]);
}

void printEncoderData() {
  Serial.print("Enc0: "); Serial.print(encoder0.read()); Serial.print("	");
  Serial.print("Enc1: "); Serial.print(encoder1.read()); Serial.print("	");
  Serial.print("Enc2: "); Serial.print(encoder2.read()); Serial.print("	");
  Serial.print("Enc3: "); Serial.print(encoder3.read()); Serial.print("	");
  Serial.print("Enc4: "); Serial.print(encoder4.read()); Serial.print("	");
  Serial.print("Enc5: "); Serial.println(encoder5.read());
}

static void loadPwmArray(int *target, const CAN_message_t &msg) {
  const uint8_t count = min<uint8_t>(6, msg.len);
  for (uint8_t i = 0; i < count; ++i) {
    target[i] = static_cast<int>(msg.buf[i]);
  }
}

void sendEncoderPositions() {
  for (int i = 0; i < 6; i++) {
    CAN_message_t msg;
    msg.id = 0x110 + i;
    msg.len = 4;
    long pos = encoders[i]->read();

    msg.buf[0] = (pos >> 24) & 0xFF;
    msg.buf[1] = (pos >> 16) & 0xFF;
    msg.buf[2] = (pos >> 8) & 0xFF;
    msg.buf[3] = pos & 0xFF;

    Can3.write(msg);
  }
}

void sendRangeOfMotion() {
  for (int i = 0; i < 6; i++) {
    CAN_message_t msg;
    msg.id = 0x130 + i;
    msg.len = 8;

    msg.buf[0] = (lowROM[i] >> 24) & 0xFF;
    msg.buf[1] = (lowROM[i] >> 16) & 0xFF;
    msg.buf[2] = (lowROM[i] >> 8) & 0xFF;
    msg.buf[3] = lowROM[i] & 0xFF;

    msg.buf[4] = (highROM[i] >> 24) & 0xFF;
    msg.buf[5] = (highROM[i] >> 16) & 0xFF;
    msg.buf[6] = (highROM[i] >> 8) & 0xFF;
    msg.buf[7] = highROM[i] & 0xFF;

    Can3.write(msg);
  }
}